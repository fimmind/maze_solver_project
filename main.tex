\documentclass[a4paper, 12pt]{article}
\usepackage[a4paper]{geometry}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{libertine}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{courier}

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,frame=leftline}

% \renewcommand{\thesection}{}
% \renewcommand{\thesubsection}{}
% \renewcommand{\thesubsubsection}{}
% \renewcommand{\theparagraph}{}

\title{Алгоритмы поиска на не взвешенных графах на примере поиска путей в лабиринтах}
\author{Виногродский Серафим}

\begin{document}
\begin{titlepage}
    \maketitle
    \tableofcontents
    \thispagestyle{empty}
\end{titlepage}

\section{Введение}
\ldots

\section{Описание реализованных алгоритмов поиска}
\subsection{Поиск в глубину (Depth-first search, DFS)}
\subsubsection{Описание алгоритма}

Поиск в глубину, как и поиск в ширину, является одним из базовых алгоритмов поиска на графах, в основе которого лежит использование стека для определения очерёдности посещения элементов графа. Для его реализации на C++ требуется 3 вспомогательные структуры:
\begin{itemize}
    \item[(1)] множество посещённых элементов графа;
    \item[(2)] стек, определяющий очерёдность посещения;
    \item[(3)] словарь родителей.
\end{itemize}

\begin{lstlisting}[language=C++]
    auto visited      = set<cell_t>({_start_pos});   // (1)
    auto search_stack = stack<cell_t>({_start_pos}); // (2)
    auto parents      = map<cell_t, cell_t>();       // (3)
\end{lstlisting}

В общем случае структура \verb|parents| является необязательной, поскольку она используется только для восстановления пути до найденного элемента, что не всегда необходимо. Поскольку в данной работе алгоритм DFS используется именно для поиска пути, а не для нахождения элемента, избавиться от структуры \verb|parents| невозможно.

Далее, пока стек \verb|search_stack| не пуст, из него изымается верхний элемент \verb|next|. Если \verb|next| подходит под условия поиска, то из словаря родителей строится путь до найденного элемента, после чего этот путь возвращается как результат поиска:

\begin{lstlisting}[language=C++]
    while (!search_stack.empty()) {
        cell_t next = search_stack.top();
        if (next == _dest_pos) {
            return build_path(parents, _start_pos, _dest_pos);
        }
        searh_stack.pop();

        // <...>
    }
\end{lstlisting}

В ином случае, то есть если искомая вершина ещё не достигнута, все до этого не посещённые дети вершины \verb|next| поочерёдно добавляются в стек \verb|search_stack|, после чего поиск продолжается уже для следующей вершины (если таковая имеется):

\begin{lstlisting}[language=C++]
    while (!search_stack.empty()) {
        // <...>

        for (cell_t child : neighbors(next)) {
            if (!visited.contains(child)) {
                parents.insert({child, next});
                visited.insert(child);
                search_stack.push(child);
            }
        }
    }
\end{lstlisting}

Следствием использования стека для определения очерёдности посещения является то, что дети только что посещённых узлов обрабатываются раньше детей узлов, посещённых до этого. Таким образом алгоритм DFS как бы старается забраться как можно глубже в структуру дерева (что вполне соответствует названию алгоритма), вместо того, что бы последовательно обрабатывать все узлы все большей и большей глубины, как это делает алгоритм BSF, который будет описан далее.

Стоит так же отметить, что приведённая здесь реализация может быть оптимизирована путём использования одной только структуры \verb|parents| вместо пары \verb|parents| и \verb|visited|, но подобный подход, пусть и не значительно, но уложил бы логику реализации алгоритма, требуя отдельной обработки определённых частных случаев. Поскольку данная работа фокусируется на сравнительной характеристике алгоритмов, а не на предельной их оптимизации, в ней подобная более оптимальная реализация подробно не рассматривается.

\subsubsection{Оценка сложности}
\label{ssub:DFS_complexity}
Пусть в связном графе, по которому производится поиск, содержится \({ V }\) вершин и \({ E }\) рёбер. В худшем случае алгоритм DFS обходит все вершины и рёбра графа. Время обработки каждой из вершин составляет \({ O(1) }\), поскольку оно включает в себя лишь работу с очередью и проверку на равенство вершины искомой вершине. Время обработки каждого из рёбер составляет \({ O(\log V) }\), поскольку оно включает в себя работу со словарями и множествами из не более чем \({ V }\) элементов. Таким образом, верхняя оценка времени выполнения алгоритма составляет \({ O(V + E \cdot \log V) }\).

Каждая вершина попадает в \verb|visited|, \verb|parents| и \verb|stack| не более одного раза, так что верхняя оценка потребления памяти составляет \({ O(V) }\).

\subsection{Поиск в ширину (Breadth-first search, BFS)}
\subsubsection{Описание алгоритма}
В общем случае, реализация алгоритма поиска в ширину полностью идентична таковому для поиска в глубину. Единственное отличие состоит в том, что для определения очерёдности посещения вместо стека используется очередь. Как следствие, алгоритм BSF гарантирует, что все  вершины заданной глубины будут посещены раньше всех вершин большей глубины, так что в процессе поиска алгоритм BFS, в отличие от DSF, как бы разрастается вширь, постепенно покрывая все большую и большую окрестность вершины, из которой начинается поиск (отсюда и название.)

Фактическая реализация этого алгоритма в данном проекте, однако, в значительной степени отличается от алгоритма DFS. Вместо прямой реализации аналогичной той, что была приведения выше для DFS, алгоритм опирается на использование функции, реализующей обобщённый шаг поиска в ширину, используемый в дальнейшем алгоритмом поиска в ширину с двух сторон. Этот подход будет более подробно описан в части \ref{ssub:BFS_implementation}.

\subsubsection{Оценка сложности}
Очереди асимптотически полностью аналогичны стекам, так что верхняя оценка и времени выполнения, и потребления памяти алгоритмом BFS совпадает с оценками для DFS (см. часть \ref{ssub:DFS_complexity}):
\begin{itemize}
    \item время выполнения --- \({ O(V + E \cdot \log V) }\),
    \item потребление памяти --- \({ O(V) }\).
\end{itemize}

\subsection{Поиск в ширину с двух сторон}
\subsubsection{Описание алгоритма}
\ldots

\subsubsection{Оценка сложности}
\ldots

\subsubsection{Реализация алгоритма поиска в ширину}
\label{ssub:BFS_implementation}
\ldots

\section{Сравнение эффективности}
\ldots

\section{Выводы}
\ldots

\end{document}
